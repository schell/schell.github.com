<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Frontend Web Development in Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="intro.html">Intro</a></li><li class="expanded "><a href="1_rust.html"><strong aria-hidden="true">1.</strong> Intro to Rust</a></li><li><ol class="section"><li class="expanded "><a href="1_rust_features.html"><strong aria-hidden="true">1.1.</strong> Features</a></li><li class="expanded "><a href="1_rust_ecosystem.html"><strong aria-hidden="true">1.2.</strong> Ecosystem</a></li><li class="expanded "><a href="1_rust_examples.html"><strong aria-hidden="true">1.3.</strong> Examples</a></li><li><ol class="section"><li class="expanded "><a href="1_rust_examples_bindings.html"><strong aria-hidden="true">1.3.1.</strong> Functions, Values and Bindings</a></li><li class="expanded "><a href="1_rust_examples_mutability.html"><strong aria-hidden="true">1.3.2.</strong> Mutability</a></li><li class="expanded "><a href="1_rust_examples_refs.html"><strong aria-hidden="true">1.3.3.</strong> References</a></li><li class="expanded "><a href="1_rust_examples_data.html"><strong aria-hidden="true">1.3.4.</strong> Data Types</a></li><li><ol class="section"><li class="expanded "><a href="1_rust_examples_methods.html"><strong aria-hidden="true">1.3.4.1.</strong> Methods</a></li><li class="expanded "><a href="1_rust_examples_traits.html"><strong aria-hidden="true">1.3.4.2.</strong> Traits</a></li></ol></li><li class="expanded "><a href="1_rust_functional.html"><strong aria-hidden="true">1.3.5.</strong> Being Functional</a></li></ol></li><li class="expanded "><a href="1_rust_links.html"><strong aria-hidden="true">1.4.</strong> Helpful Links</a></li></ol></li><li class="expanded "><a href="2_browser.html"><strong aria-hidden="true">2.</strong> Rust in the Browser</a></li><li><ol class="section"><li class="expanded "><a href="2_web_sys.html"><strong aria-hidden="true">2.1.</strong> web-sys</a></li><li><ol class="section"><li class="expanded "><a href="2_web_sys_alert.html"><strong aria-hidden="true">2.1.1.</strong> alert</a></li><li class="expanded "><a href="2_web_sys_alert_button.html"><strong aria-hidden="true">2.1.2.</strong> alert with button</a></li></ol></li><li class="expanded "><a href="2_browser_links.html"><strong aria-hidden="true">2.2.</strong> Helpful Links</a></li></ol></li><li class="expanded "><a href="3_frameworks.html"><strong aria-hidden="true">3.</strong> Libraries and Frameworks</a></li><li><ol class="section"><li class="expanded "><a href="3_gloo.html"><strong aria-hidden="true">3.1.</strong> Gloo</a></li><li class="expanded "><a href="3_mogwai.html"><strong aria-hidden="true">3.2.</strong> mogwai</a></li><li class="expanded "><a href="3_sauron.html"><strong aria-hidden="true">3.3.</strong> sauron</a></li><li class="expanded "><a href="3_yew.html"><strong aria-hidden="true">3.4.</strong> yew</a></li><li class="expanded "><a href="3_benchmarks.html"><strong aria-hidden="true">3.5.</strong> Benchmarks</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Frontend Web Development in Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome" id="welcome">Welcome!</a></h1>
<p>Welcome to a tutorial about writing front end web applications using Rust.
Roughly I've broken this up into a couple sections:</p>
<ul>
<li><a href="./1_rust.html">A hard and fast introduction to Rust</a></li>
<li><a href="./2_browser.html">A hard and fast introduction to Rust-to-WASM</a> compilation and
using <a href="https://crates.io/crates/web-sys">web-sys</a> to write Rust that runs in the
browser.</li>
<li><a href="./3_frameworks.html">A tour of a few libraries and frameworks</a> to use that make
application development generally easier (I hope).</li>
</ul>
<p>This guide is being tentatively hosted at
<a href="http://schell.github.io/intro-to-rust-web/">schell.github.io/intro-to-rust-web-dev</a>.</p>
<p>Let's dive in! 🏊🏽</p>
<h1><a class="header" href="#a-lightspeed-introduction-to-rust" id="a-lightspeed-introduction-to-rust">A Lightspeed Introduction to Rust</a></h1>
<p><img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="rust logo" /></p>
<p>Rust is a programming language.</p>
<p>As of this writing it's at version 1.40, only ~9 years old!</p>
<p><a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">Rust 1.0 was released in 2015</a></p>
<p>Compare that to</p>
<ul>
<li>JavaScript, 1995 ~24 years old</li>
<li>Haskell, 1990 ~30 years old</li>
</ul>
<p><a href="https://research.mozilla.org/rust/">Mozilla was the first investor in Rust</a>,
being heavily involved in the development of the language.
Coincedentally Mozilla was also heavily involved in the development of JavaScript
(not just) through its beginnings as an arm of the
<a href="https://en.wikipedia.org/wiki/Netscape">Netscape Communications Corporation</a>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/en/thumb/4/49/Mozilla_boxing.jpg/175px-Mozilla_boxing.jpg" alt="early mozilla mascot" /></p>
<p>People who write Rust are endearingly called &quot;Rustaceans&quot;.</p>
<p><a href="https://www.rustacean.net/">Rust has a (unofficial) mascot named Ferris.</a>
<img src="https://www.rustacean.net/assets/rustacean-orig-noshadow.png" alt="ferris the crab" /></p>
<p><a href="https://rustup.rs/">Get Rust!</a></p>
<h1><a class="header" href="#rusts-features" id="rusts-features">Rust's Features</a></h1>
<ul>
<li>
<p>compiled w/ the <code>rustc</code> compiler, which is self-hosted (written in Rust)</p>
</li>
<li>
<p>a strong, static typing discipline, similar in feel to Haskell 98 but different</p>
</li>
<li>
<p>imperative or functional style, a bit like Scala and Swift. You can mix'n'match
your functional and imperative code - but EVERYTHING IS IN IO. (Opinion): this
is not bad.</p>
</li>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Eager_evaluation">eager evaluation</a> of
expressions.</p>
</li>
<li>
<p>type variables or <a href="https://doc.rust-lang.org/rust-by-example/generics.html">generics</a></p>
</li>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Trait_(computer_programming)">traits</a>
(which are a bit like interfaces or type classes, less like classes but you get
the point)</p>
</li>
<li>
<p>a new, novel concept called a &quot;borrow checker&quot;, which obviates garbage
collection (more on this later, because it is a big deal). It makes memory
management rather slick and easy.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/rust-by-example/macros.html">macros!</a> The macro
system provides compile-time metaprogramming much like TemplateHaskell, but
unlike the Haskell community, the Rust community seems very inclined to use
macros whenever they feel like it (I personally like this)</p>
</li>
</ul>
<h2><a class="header" href="#rusts-non-features" id="rusts-non-features">Rust's Non-features</a></h2>
<ul>
<li>
<p>No higher-kinded types ... (Opinion): this means there are no practical
implementations of category theory concepts like Category, Arrow, Functor,
Monoid, Monad, etc.
This is a good thing, <em>mostly</em>.</p>
</li>
<li>
<p>No classical inheritance (and no prototypal inheritance, for that matter). This
is good.</p>
</li>
</ul>
<h1><a class="header" href="#ecosystem" id="ecosystem">Ecosystem</a></h1>
<p>Rust has a very helpful and friendly community as well as a thriving, though a
bit fledgling ecosystem, backed by the
<a href="https://doc.rust-lang.org/cargo/">cargo package manager</a>. Packages (libraries)
are colloquially called &quot;crates&quot;. Crates are uploaded to the
<a href="https://crates.io/">crates.io</a> package repository where they are hosted over
HTTP, along with documentation.</p>
<blockquote>
<p>Hint:
If you use <a href="https://duckduckgo.com/">duckduckgo</a> as your search engine you can
search for crates using bang syntax like <code>!crates mogwai</code>, which will warp you
straight to search results for that crate on crates.io (in this case that's the
<code>mogwai</code> crate).</p>
</blockquote>
<p>You can find help at the <a href="https://www.reddit.com/r/rust/">rust sub-reddit</a>, the
freenode IRC <code>##rust</code> channel or <a href="https://www.rust-lang.org/community">more</a>.</p>
<p>Ok, enough - what does Rust look like?</p>
<h1><a class="header" href="#rust-examples" id="rust-examples">Rust Examples</a></h1>
<p>Next we'll see some examples of actual Rust code.</p>
<h1><a class="header" href="#functions-values-and-bindings" id="functions-values-and-bindings">Functions, Values and Bindings</a></h1>
<p>Rust is C-like, with braces and a mostly imperative style. Here's hello world:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
  let name = &quot;world&quot;;
  print!(&quot;Hello {}&quot;, name);
}
</code></pre></pre>
<p><code>let</code> bindings allow us to bind names to values, and names may be rebound:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
  let x:f32 = 1.0;
  let y:f32 = 2.5;
  let name:f32 = x + y;
  let name:String = format!(&quot;Number {:.2}&quot;, name);
  print!(&quot;Hello {}&quot;, name);
}
</code></pre></pre>
<h1><a class="header" href="#mutability" id="mutability">Mutability</a></h1>
<p>Mutable values are denoted using the <code>mut</code> keyword within a <code>let</code> binding, or in
the parameters of a function or pattern match (basically anywhere you can name a
value):</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
  let mut name = &quot;unused_name&quot;;
  name = &quot;Cuco&quot;;
  print!(&quot;Hello {}&quot;, name);
}
</code></pre></pre>
<h1><a class="header" href="#references" id="references">References</a></h1>
<p>Like C and C++, Rust supports passing values by value or by reference. A
reference is a pointer to a value. Unlike those languages, passing a value
&quot;invokes&quot; the borrow checker. The borrow checker ensures that no more than one
mutable reference to a value is obtained at any one time. This prevents a lot of
bugs. To pass a value by reference, prefix the name with <code>&amp;</code>. To pass a value by
<em>mutable</em> reference, prefix the name with <code>&amp;mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn add_one_mut(x: &amp;mut i32) {
  // Here we dereference the variable to add one to its value
  *x += 1;
}

fn main() {
  let mut x = 6;
  add_one_mut(&amp;mut x); // &lt;- see that we're passing a mutable reference
  add_one_mut(&amp;mut x);
  println!(&quot;Hello {}&quot;, x);
}
</code></pre></pre>
<p>Here we'll try to hold one mutable reference and pass another at the same time:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn add_one_mut(x: &amp;mut i32) {
  *x += 1;
}

fn main() {
  let mut x = 6;

  // Hold a mutable ref to x
  let may_mut_x:Option&lt;&amp;mut i32&gt; = Some(&amp;mut x);

  // Remove the comment on the next line...
  // add_one_mut(&amp;mut x);

  println!(&quot;Hello {:?}&quot;, may_mut_x);
}
</code></pre></pre>
<p>But you may have as many immutable references as you like, so long as none of
those references try to &quot;outlive&quot; the original value.</p>
<pre><pre class="playpen"><code class="language-rust">/// Returns one plus the value of the reference passed
fn add_one(x: &amp;i32) -&gt; i32 {
  *x + 1
}

fn main() {
  let x = 3;
  let may_x_ref = Some(&amp;x);
  let y = add_one(&amp;x);
  let z = add_one(&amp;y);
  println!(&quot;Hello {} {} {} {:?}&quot;, x, y, z, may_x_ref);
}
</code></pre></pre>
<h1><a class="header" href="#data-types" id="data-types">Data Types</a></h1>
<p>Rust has two kinds of data structures.</p>
<h2><a class="header" href="#struct" id="struct">Struct</a></h2>
<p>Like Haskell's records, without the record field update baggage.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Person {
  name: String
}

struct Place {
  name: String,
  latitude: f32,
  longitude: f32,
}

struct Thing {
  description: String
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#enum" id="enum">Enum</a></h2>
<p>Enums can be C-like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Noun {
  Person,
  Place,
  Thing
}
<span class="boring">}
</span></code></pre></pre>
<p>Or they can be more like Haskell's sum types:</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person {
  name: String
}

#[derive(Debug)]
struct Place {
  name: String,
  latitude: f32,
  longitude: f32,
}

#[derive(Debug)]
struct Thing {
  description: String
}

#[derive(Debug)]
enum Noun {
  Person(Person),
  Place(Place),
  Thing(Thing)
}

fn main() {
  let thing =
    Thing {
      description: &quot;A broken can opener&quot;.to_string()
    };
  let mut noun =
    Noun::Thing(thing);

  println!(&quot;{:#?}&quot;, noun);

  match &amp;mut noun {
    Noun::Thing(thing) =&gt; {
      thing.description = &quot;A can't opener&quot;.to_string()
    }
    _ =&gt; {}
  }

  println!(&quot;{:#?}&quot;, noun);
}
</code></pre></pre>
<h1><a class="header" href="#methods" id="methods">Methods</a></h1>
<p>Just like in C++ and Java, Rust has methods. Methods are functions that appear
to &quot;live inside&quot; the data they operate on.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    /// the `self` keyword is analogous to `this` in C++ and Javascript,
    /// or `self` in Objective-C. It means &quot;the value this function was
    /// called on&quot;.
    ///
    /// Notice how we pass an immutable reference to the circle this
    /// function is called on. We could also pass a mutable reference
    /// which would allow the function to mutate the circle in-place.
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/1.8.0/book/method-syntax.html">More info on method syntax</a></p>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<p>Traits allow us to create an interface that types can implement (or not).</p>
<pre><pre class="playpen"><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}

fn main() {
  let c = Circle {
      x: 0.0f64,
      y: 0.0f64,
      radius: 1.0f64,
  };

  print_area(c);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/1.8.0/book/traits.html">More info on traits</a></p>
<h1><a class="header" href="#being-functional" id="being-functional">Being Functional</a></h1>
<h2><a class="header" href="#lambdas" id="lambdas">Lambdas!</a></h2>
<p>Rust is a functional language in that it supports creating, storing and passing
anonymous functions as parameters to other functions.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
  let add_one =
    |x: &amp;i32| -&gt; i32 {
      *x + 1
    };

  let add_one_mut =
    |x: &amp;mut i32| {
      *x += 1
    };

  let mut n = add_one(&amp;0);
  add_one_mut(&amp;mut n);
}
</code></pre></pre>
<h2><a class="header" href="#options-folds-maps-and-more" id="options-folds-maps-and-more">Options, folds, maps and more!</a></h2>
<p>Through the use of <a href="https://doc.rust-lang.org/1.8.0/book/traits.html">Traits</a> we
can use functions like <code>map</code>, <code>filter</code>, <code>fold</code> and friends on many different
structures.</p>
<p>Map the inner value of an <code>Option</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let may_i32:Option&lt;i32&gt; = Some(88);
  let may_string:Option&lt;String&gt; =
    may_i32
    .map(|n| format!(&quot;{}&quot;, n));

  println!(&quot;{:?}&quot;, may_string);
}
</code></pre></pre>
<p>Fold over a vector and sum the elements:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let items:Vec&lt;i32&gt; = vec![0, 1, 2, 3];
  let sum =
    items
    .iter()
    .fold(
      0,
      |acc, i:&amp;i32| acc + *i  // &lt;- look, you don't always need brackets on lambdas
    );

  println!(&quot;The sum of {:?} is {}&quot;, items, sum);
}
</code></pre></pre>
<p>Try a filter before the sum:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
  let items:Vec&lt;i32&gt; = vec![0, 1, 2, 3];
  let sum =
    items
    .iter()
    .filter(|i| **i &lt;= 2) // &lt;- keep i if it is &lt;= 2
    .fold(
      0,
      |acc, i| acc + *i
    );

  println!(&quot;The sum of numbers less that or equal to 2 in {:?} is {}&quot;, items, sum);
}
</code></pre></pre>
<p>Do the same thing but with an imperative style:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let items:Vec&lt;i32&gt; = vec![0, 1, 2, 3];

  let mut sum = 0;
  for i in items.iter() {
    if *i &lt;= 2 {
      sum += i;
    }
  }

  println!(&quot;The sum of numbers less that or equal to 2 in {:?} is {}&quot;, items, sum);
}
</code></pre></pre>
<h1><a class="header" href="#helpful-links" id="helpful-links">Helpful Links</a></h1>
<ul>
<li><a href="https://www.rust-lang.org/">Official rust-lang site</a></li>
<li><a href="https://doc.rust-lang.org/1.8.0/book/">The Rust Book</a></li>
</ul>
<h1><a class="header" href="#rust-in-the-browser" id="rust-in-the-browser">Rust in the Browser</a></h1>
<p>Rust cross-compiles to <a href="https://webassembly.org/">WebAssembly</a>.</p>
<p>You'll need <a href="https://rustwasm.github.io/wasm-pack/installer/">wasm-pack</a> to
convert your Rust into WASM and to shim it into an html file.</p>
<p>Once you have <code>wasm-pack</code> you can use <code>cargo generate</code> (which can be installed
with <code>cargo install cargo-generate</code>) to create a template project:</p>
<pre><code class="language-bash">cargo generate --git https://github.com/schell/mogwai-template.git
</code></pre>
<p>The <code>cd</code> into your new project and:</p>
<pre><code class="language-bash">wasm-pack build --target no-modules
</code></pre>
<p>Then, if you don't already have it, <code>cargo install basic-http-server</code> or use your
favorite alternative to serve the files for your app:</p>
<pre><code class="language-bash">basic-http-server -a 127.0.0.1:8888
</code></pre>
<p>With <code>wasm-pack</code> you'll be able to create Rust packages that can be consumed and
published with <code>npm</code>.</p>
<h1><a class="header" href="#web-sys" id="web-sys">web-sys</a></h1>
<p><a href="https://crates.io/crates/web-sys">web-sys</a> provides bindings for all Web APIs and
is a procedurally generated crate from WebIDL.</p>
<p>It's the defacto way to interact with a browser's DOM and other APIs.</p>
<p>It's part of a bigger project called
<a href="https://rustwasm.github.io/docs/wasm-bindgen/">wasm-bindgen</a>.</p>
<h2><a class="header" href="#a-fair-warning" id="a-fair-warning">A fair warning</a></h2>
<p>Browser APIs are inherently un-safe. Any value in JavaScript may be <code>null</code>. As a
result strong, static typed languages have to jump through hoops to assure that
the programmer is working with the values they expect. In Rust this means doing a
lot of <code>map</code>ing and <code>unwrap</code>ing. The good news is that once you have a value, you
really have it.</p>
<h2><a class="header" href="#comparisons" id="comparisons">Comparisons</a></h2>
<p>The <code>web-sys</code> crate is the low level crate that other Rust libraries and
frameworks build on top of. It is the bridge between Rust and your browser.</p>
<p>It's a bit like Haskell's <a href="https://hackage.haskell.org/package/jsaddle">jsaddle</a>
and <a href="https://hackage.haskell.org/package/jsaddle-dom">jsaddle-dom</a>, which we use
at <a href="https://formation.ai/">Formation.ai</a>.</p>
<p>It's also a bit like interacting with your browser in JavaScript using the web
dev console. Very useful, but probably not the best way to structure large web
applications.</p>
<h1><a class="header" href="#alert-" id="alert-">Alert 🚨</a></h1>
<p>Lets write an alert.</p>
<h2><a class="header" href="#a-note-on-using-web-sys-apis" id="a-note-on-using-web-sys-apis">A note on using web-sys APIs</a></h2>
<p>We can find the API we need using a
<a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/?search=alert">search</a>
within the web-sys docs:</p>
<blockquote>
<p><code>pub fn alert_with_message(&amp;self, message: &amp;str) -&gt; Result&lt;(), JsValue&gt;</code></p>
<p>The alert() method</p>
<p>MDN Documentation</p>
<p><em>This API requires the following crate features to be activated: Window</em></p>
</blockquote>
<p>This last bit about &quot;This API require the following...&quot; is important. <code>web-sys</code>
is huuuuuge because it contains a lot of APIs. To cut down on compile times, etc.
the authors decided to have each API be <em>opt-in</em>, so you must add that API to your
<code>Cargo.toml</code>'s features list. Luckily we have a project template that includes
this stuff (along with a little note):</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3&quot;
# Add more web-sys API's as you need them
features = [
  &quot;HtmlInputElement&quot;,
]
</code></pre>
<p>To use the <code>Window</code> API we have to add &quot;Window&quot; to the list of features:</p>
<pre><code class="language-toml">features = [
  &quot;HtmlInputElement&quot;,
  &quot;Window&quot;
]
</code></pre>
<p>Now we can write our little app:</p>
<pre><code class="language-rust no_run noplaypen">use wasm_bindgen::prelude::*;
use web_sys::window;

pub fn main() -&gt; Result&lt;(), JsValue&gt; {
  let window = window().unwrap();
  window.alert_with_message(&quot;Hello from WASM!&quot;)
}
</code></pre>
<h1><a class="header" href="#alert-with-button-" id="alert-with-button-">Alert with button ⚙️</a></h1>
<p>Now let's look at building some DOM.</p>
<p>First we'll need to add some more APIs as features to our Cargo.toml:</p>
<pre><code class="language-toml">features = [
  &quot;Document&quot;,
  &quot;Element&quot;,
  &quot;EventTarget&quot;,
  &quot;HtmlElement&quot;,
  &quot;Node&quot;,
  &quot;Window&quot;,
]
</code></pre>
<p>Then we can write our app:</p>
<pre><code class="language-rust no_run noplaypen">use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::{
  window,
  Element,
  HtmlElement,
  Node
};

pub fn main() -&gt; Result&lt;(), JsValue&gt; {
  // Get a handle to our window and document
  let window = window().unwrap();
  let document =
    window
    .document()
    .unwrap();

  // Create the button element
  let button:Element =
    document
    .create_element(&quot;button&quot;)
    .unwrap();
  button
    .dyn_ref::&lt;HtmlElement&gt;()
    .unwrap()
    .set_inner_text(&quot;Trigger&quot;);

  // Get a handle on the document's body
  let body =
    document
    .body()
    .unwrap();

  // Add the button to the DOM
  body
    .dyn_into::&lt;Node&gt;()
    .unwrap()
    .append_child(&amp;button)
    .unwrap();

  // Create a Javascript closure that will trigger an alert
  let cb =
    Closure::wrap(Box::new(|| {
      web_sys::window()
        .unwrap()
        .alert_with_message(&quot;You hit the button!&quot;)
        .unwrap();
    }) as Box&lt;dyn FnMut()&gt;);

  // Add the closure as a listener that procs on click
  button
    .add_event_listener_with_callback(&quot;click&quot;, cb.as_ref().unchecked_ref())
    .unwrap();

  // Usually Rust would hold on to the closure (or else it is dropped)
  // but here we'll forget about it, which means it will be around forever.
  cb.forget();

  Ok(())
}
</code></pre>
<p>And see our work completed!</p>
<iframe
  style="border:none"
  src="web-sys-examples/index.html?alert_button=true"
  width="100%">
</iframe>
<p>That's an awful lot of code for a simple button that triggers an alert, but it's
fast and it's cautious.</p>
<h1><a class="header" href="#helpful-links-for-rust---wasm" id="helpful-links-for-rust---wasm">Helpful Links for Rust -&gt; WASM</a></h1>
<ul>
<li><a href="https://rustwasm.github.io/">Rust and WebAssembly</a></li>
</ul>
<h1><a class="header" href="#frameworks" id="frameworks">Frameworks</a></h1>
<p>Phwew! You've made it this far. In the last section <a href="./2_web_sys_alert_button.html">we saw how complicated a
simple app can be</a>. It takes an awful lot of code
to simply create a button and attach a callback. Most of that code is about
safely acquiring objects and calling functions, or have to do with marshalling
values between Rust and the browser.</p>
<p>It would be a bummer to have to write this much code for every user experience,
so let's take a quick tour of libraries that will abstract away the complexity.</p>
<table><thead><tr><th>library</th><th align="center">has vdom</th><th align="center">is elm-like</th><th align="center">low level (does the user see <code>web-sys</code>?)</th></tr></thead><tbody>
<tr><td><a href="https://github.com/rustwasm/gloo">gloo</a></td><td align="center"></td><td align="center"></td><td align="center">yes</td></tr>
<tr><td><a href="https://github.com/schell/mogwai">mogwai</a></td><td align="center"></td><td align="center">sometimes</td><td align="center">kinda</td></tr>
<tr><td><a href="https://github.com/ivanceras/sauron">sauron</a></td><td align="center">yes</td><td align="center">yes</td><td align="center"></td></tr>
<tr><td><a href="https://github.com/yewstack/yew">yew</a></td><td align="center">yes</td><td align="center">yes</td><td align="center"></td></tr>
</tbody></table>
<h1><a class="header" href="#gloo" id="gloo">Gloo</a></h1>
<p>Gloo is a library that adds some much needed clean-up on top of <code>web-sys</code>. It
makes writing <code>web-sys</code> code look a lot like writing regular javascript, only in
Rust!</p>
<h3><a class="header" href="#goals" id="goals">Goals</a></h3>
<ul>
<li>fast</li>
<li>reliable</li>
<li>small (code size)</li>
<li>idiomatic</li>
</ul>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<pre><code class="language-rust ignore">use gloo::{events::EventListener, timers::callback::Timeout};
use wasm_bindgen::prelude::*;

pub struct DelayedHelloButton {
    button: web_sys::Element,
    on_click: events::EventListener,
}

impl DelayedHelloButton {
    pub fn new(document: &amp;web_sys::Document) -&gt; Result&lt;DelayedHelloButton, JsValue&gt; {
        // Create a `&lt;button&gt;` element.
        let button = document.create_element(&quot;button&quot;)?;

        // Listen to &quot;click&quot; events on the button.
        let button2 = button.clone();
        let on_click = EventListener::new(&amp;button, &quot;click&quot;, move |_event| {
            // After a one second timeout, update the button's text content.
            let button3 = button2.clone();
            Timeout::new(1_000, move || {
                button3.set_text_content(Some(&quot;Hello from one second ago!&quot;));
            })
            .forget();
        });

        Ok(DelayedHelloButton { button, on_click })
    }
}
</code></pre>
<h1><a class="header" href="#mogwai" id="mogwai">mogwai</a></h1>
<p>Mogwai goes one step further than Gloo and provides patterns that make creating
DOM and interacting with it declarative and function. You still interact with
<code>web-sys</code>, but there are no event listeners or callbacks to deal with. It is
inspired by Haskell and Elm, so it looks a bit functional and components use a
familiar Elm update concept.</p>
<h3><a class="header" href="#goals-1" id="goals-1">Goals</a></h3>
<ul>
<li>declarative DOM</li>
<li>elm-like components</li>
<li>explicit updates</li>
<li>small (code size)</li>
<li>fast</li>
</ul>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<p>Here is an example of a button that counts its own clicks. Simple gizmos like
this don't need the elm-like component update scenario, so it looks very
functional:</p>
<pre><code class="language-rust ignore">extern crate mogwai;
use mogwai::prelude::*;

let (tx, rx) =
  txrx_fold(
    0,
    |n:&amp;mut i32, _:&amp;Event| -&gt; String {
      *n += 1;
      if *n == 1 {
        &quot;Clicked 1 time&quot;.to_string()
      } else {
        format!(&quot;Clicked {} times&quot;, *n)
      }
    }
  );

button()
  .style(&quot;cursor&quot;, &quot;pointer&quot;)
  .rx_text(&quot;Clicked 0 times&quot;, rx)
  .tx_on(&quot;click&quot;, tx)
  .build().unwrap()
  .run().unwrap()
</code></pre>
<p>Here is an example of the same thing using an elm-like approach:</p>
<pre><code class="language-rust ignore">use mogwai::prelude::*;

pub struct Button {
  pub clicks: i32
}

#[derive(Clone)]
pub enum ButtonIn {
  Click
}

#[derive(Clone)]
pub enum ButtonOut {
  Clicks(i32)
}

impl Component for Button {
  type ModelMsg = ButtonIn;
  type ViewMsg = ButtonOut;

  fn update(
    &amp;mut self,
    msg: &amp;ButtonIn,
    tx_view: &amp;Transmitter&lt;ButtonOut&gt;,
    _subscriber: &amp;Subscriber&lt;ButtonIn&gt;
  ) {
    match msg {
      ButtonIn::Click =&gt; {
        self.clicks += 1;
        tx_view.send(&amp;ButtonOut::Clicks(self.clicks))
      }
    }
  }

  fn builder(
    &amp;self,
    tx: Transmitter&lt;ButtonIn&gt;,
    rx: Receiver&lt;ButtonOut&gt;
  ) -&gt; GizmoBuilder {
    button()
      .style(&quot;cursor&quot;, &quot;pointer&quot;)
      .rx_text(&quot;Clicked 0 times&quot;, rx.branch_map(|msg| {
        match msg {
          ButtonOut::Clicks(n) =&gt; format!(&quot;Clicked {} times&quot;, n)
        }
      }))
      .tx_on(&quot;click&quot;, tx.contra_map(|_| ButtonIn::Click))
  }
}

Button{ clicks: 0 }
  .into_component()
  .build().unwrap()
  .run().unwrap()
</code></pre>
<h1><a class="header" href="#sauron" id="sauron">sauron</a></h1>
<p>Sauron abstracts out <code>web-sys</code> completely in favor of a close clone of Elm. There
are no event listeners and callbacks.</p>
<h2><a class="header" href="#example-2" id="example-2">Example</a></h2>
<pre><code class="language-rust ignore">use sauron::html::attributes::*;
use sauron::html::events::*;
use sauron::*;
use sauron::Component;
use sauron::Node;
use sauron::Program;
use sauron::Cmd;
use wasm_bindgen::prelude::*;
use log::*;

#[derive(Debug, PartialEq, Clone)]
pub enum Msg {
    Click,
}

pub struct App {
    click_count: u32,
}

impl App {
    pub fn new() -&gt; Self {
        App { click_count: 0 }
    }
}

impl Component&lt;Msg&gt; for App {

    fn view(&amp;self) -&gt; Node&lt;Msg&gt; {
        div!(
            [class(&quot;some-class&quot;), id(&quot;some-id&quot;), attr(&quot;data-id&quot;, 1)],
            [
                input!(
                    [
                        class(&quot;client&quot;),
                        type_(&quot;button&quot;),
                        value(&quot;Click me!&quot;),
                        onclick(|_| {
                            trace!(&quot;Button is clicked&quot;);
                            Msg::Click
                        }),
                    ],
                    [],
                ),
                text!(&quot;Clicked: {}&quot;, self.click_count),
            ],
        )
    }

    fn update(&amp;mut self, msg: Msg) -&gt; Cmd&lt;Self, Msg&gt; {
        trace!(&quot;App is updating from msg: {:?}&quot;, msg);
        match msg {
            Msg::Click =&gt; {
                self.click_count += 1;
                Cmd::none()
            }
        }
    }

}
</code></pre>
<h1><a class="header" href="#yew" id="yew">yew</a></h1>
<p>Yew is one of the larger frameworks for building web apps in Rust. It seems to be
more about multi-threading and concurrency, though at the time of this writing
WASM in your browser is single threaded AFAICT.</p>
<h3><a class="header" href="#example-3" id="example-3">Example</a></h3>
<pre><code class="language-rust ignore">use yew::{html, Component, ComponentLink, Html, ShouldRender};

struct Model {
    link: ComponentLink&lt;Self&gt;,
}

enum Msg {
    DoIt,
}

impl Component for Model {
    // Some details omitted. Explore the examples to see more.

    type Message = Msg;
    type Properties = ();

    fn create(_: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
        Model { link }
    }

    fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
        match msg {
            Msg::DoIt =&gt; {
                // Update your model on events
                true
            }
        }
    }

    fn view(&amp;self) -&gt; Html {
        let onclick = self.link.callback(|_| Msg::DoIt);
        html! {
            // Render your model here
            &lt;button onclick=onclick&gt;{ &quot;Click me!&quot; }&lt;/button&gt;
        }
    }
}

fn main() {
    yew::start_app::&lt;Model&gt;();
}
</code></pre>
<h1><a class="header" href="#benchmarks" id="benchmarks">Benchmarks</a></h1>
<p>Using the canonical TodoMVC for most of these libraries (and more) you can bench
their performance with regard to DOM updates.
<a href="http://schell.github.io/mogwai/todomvc/perf/">Try it yourself here</a>. Here are
the results I got:</p>
<p><img src="./img/perf.png" alt="rust todomvc bench" /></p>
<p>I believe <code>mogwai</code> is fastest here specifically because of the lack of vdom. In
my opinion it hits a good power-to-weight ratio and achieves its goals. I'm
biased though because I wrote it, lol 😊.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
